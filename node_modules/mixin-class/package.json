{
  "name": "mixin-class",
  "version": "2.0.2",
  "description": "mixin style inherit",
  "main": "index.js",
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/youngjay/mixin-class.git"
  },
  "keywords": [
    "mixin",
    "inherit"
  ],
  "author": {
    "name": "hiyoungjay@gmail.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/youngjay/mixin-class/issues"
  },
  "homepage": "https://github.com/youngjay/mixin-class",
  "devDependencies": {
    "gulp": "^3.6.1",
    "gulp-concat": "^2.2.0"
  },
  "readme": "mixin-class\n===========\nmixin style inherit\n\n\n```javascript\n'use strict';\n\nvar mixin = require('../index');\nvar assert = require('assert');\n\ndescribe('mixin(opt0 ... optN) return a class', function() {\n    it('mixin()会返回一个构造函数', function() {\n        var Class = mixin();\n        var a = new Class()\n        assert(a instanceof Class);\n    });\n\n    it('mixin(opt0...optN)可以接受object作为参数，这些object的属性会被添加到返回的类prototype', function() {\n        var Class = mixin(\n                {\n                    a: 1\n                }, \n                {\n                    b: 2\n                }\n            );\n\n        var o = new Class();\n        assert.equal(o.a, 1);\n        assert.equal(o.b, 2);\n    });\n\n    it('mixin() === mixin.extend()', function() {\n        var Class = mixin.extend(\n                {\n                    a: 1\n                }, \n                {\n                    b: 2\n                }\n            );\n\n        var o = new Class();\n        assert.equal(o.a, 1);\n        assert.equal(o.b, 2);\n    })\n\n    it('mixin(opt0...optN)可以接受function作为参数，这些function会在new的时候依次被调用', function() {\n        var Class = mixin(\n                function() {\n                    this.a = 1;\n                },\n                function() {\n                    this.b = 2\n                }\n            );\n\n        var o = new Class();\n        assert.equal(o.a, 1);\n        assert.equal(o.b, 2);\n    });\n\n    it('mixin(opt0...optN)可以接受class作为参数，这些class的prototype的属性会被添加到返回的类prototype，这些class的构造函数会在new的时候依次被调用', function() {\n        var C = function() {\n            this.a = 1;\n        }\n        C.prototype.b = 2;\n\n\n        var Class = mixin(C);\n\n        var o = new Class();\n        assert.equal(o.a, 1);\n        assert.equal(o.b, 2);\n    });\n\n    it('传入的function调用时会传入arguments', function() {\n        var Class = mixin(function(a, b) {\n            this.a = a;\n        }, function(a, b) {\n            this.b = b;\n        })\n\n        var o = new  Class(1, 2);\n        assert.equal(o.a, 1);\n        assert.equal(o.b, 2);\n    })\n\n    it('传入的function会去重', function() {\n        var calledTimes = 0;\n        var Ctor = function() {\n            calledTimes++;\n        };\n        var Class = mixin(Ctor, Ctor, mixin(Ctor));\n        var a = new Class();\n        assert.equal(calledTimes, 1)\n    })\n})\n\ndescribe('mixin ctor', function() {\n    it('每个构造函数的返回值会作为下一个构造函数的this', function() {\n        var a = {};\n        var b = {};\n        var c = {};\n\n\n        var A = function() {\n            return a;\n        };\n\n        var B = function() {\n            assert.equal(this, a);\n            return b;\n        };\n\n        var C = function() {\n            assert.equal(this, b);\n            return c;\n        }\n\n        var o = new (mixin(A, B, C))();\n\n\n        assert.equal(o, c)\n\n    })\n\n});\n```",
  "readmeFilename": "README.md",
  "gitHead": "3b64fefeb8b65edc61a858e1ffc93183c59acba6",
  "_id": "mixin-class@2.0.2",
  "_shasum": "24bd63052719759a29b066c08d8bc3363325f70b",
  "_from": "mixin-class@"
}
